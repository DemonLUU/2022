<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title></title>
</head>

<body>
</body>
<script>
	class myPromise {
		constructor(fn) {
			//初始状态
			this.state = 'pending'
			this.value = null //参数 成功回调的值
			this.reason = null //失败的原因
			//状态为pending时需要将成功回调 失败回调的函数存储起来 当状态变更后再执行这些回调函数
			this.onFuList = []
			this.onReject = []
			try {
				//修改this指向
				fn(this.resolve.bind(this), this.reject.bind(this))
			} catch (e) {
				this.reject(e)
			}

		}

		resolve (value) {
			//状态只能改变一次
			if (this.state === 'pending') {
				this.state = 'ful'
				this.value = value
				//循环执行
				this.onFuList.forEach(cb => {
					cb(this.value)
				})
			}
		}

		reject (reason) {
			if (this.state === 'pending') {
				this.state = 'reject'
				this.reason = reason
				this.onReject.forEach(cb => {
					cb(this.reason)
				})
			}
		}

		then (onful, onreject) {
			//then支持链式调用 then返回新的promise对象
			let promise2 = new myPromise((resolve, reject) => {
				//两个参数 成功回调 失败回调
				if (this.state === 'ful') {
					//状态变更后去执行then 异步调用使用setTimeout 宏任务
					setTimeout(() => {
						try {
							//不是函数类型直接返回值

							//判断是不是函数类型 若不是 直接返回值
							if (typeof onful !== 'function') {
								resolve(this.value)
							} else {
								//返回promise类型 进行状态比较
								let x = onful(this.value)
								resolvePromise(promise2, x, resolve, rject)
							}

						} catch (e) {
							reject(e)
						}
					})


				} else if (this.state === 'reject') {
					setTimeout(() => {
						try {
							if (typeof onreject !== 'function') {
								reject(this.reason)
							} else {
								let x = onreject(this.reason)
								resolvePromise(promise2, x, resolve, reject)
							}

						} catch (e) {
							reject(e)
						}
					})



				} else if (this.state === 'pending') {
					this.onFuList.push(() => {
						setTimeout(() => {
							try {
								if (typeof onful !== 'function') {
									resolve(this.value)
								} else {
									let x = onful(this.value)
									resolvePromise(promise2, x, resolve, reject)
								}

							} catch (e) {
								reject(e)
							}

						})

					})
					this.onReject.push(() => {
						setTimeout(() => {
							try {
								if (typeof onreject !== 'function') {
									reject(this.reason)
								} else {
									let x = onreject(this.reason)
									resolvePromise(promise2, x, resolve, reject)
								}
							} catch (e) {
								reject(e)
							}


						})
					})

				}
			})

			return promise2
		}
		//返回promise类型
	}

	function resolvePromise (promise2, x, resolve, reject) {
		//指向一个对象 
		if (x === promise2) {
			throw new TypeError('xxxx')
		}
		//x 符合A+规范 then拿返回值 返回值可依然是promise对象进行then处理
		if (x instanceof myPromise) {
			x.then(y => {
				resolvePromise(promise2, x, resolve, reject)
			}, reject)
		}
		//其他规范的 1、判断x是否为对象或函数 2、判断x.then是否为函数
		else if (x !== null && ((typeof x === 'object' || (typeof x === 'function')))) {
			try {
				let then = x.then
			} catch (e) {
				return reject(e)
			}
			if (typeof then === 'function') {
				try {
					then.call(
						x,
						y => {
							resolvePromise(promise2, y, resolve, reject)
						},
						r => {
							reject(r)
						})
				} catch (e) {
					reject(e)
				}
			} else {
				resolve(x)
			}
		} else {
			return resolve(x)
		}
	}
	// console.log('----11-')
	let p = new myPromise(function (resolve, reject) {
		//做一些异步操作
		resolve('要返回的数据可以任何数据例如接口返回数据');
		// setTimeout(function() {
		// 	console.log('执行完成Promise');

		// }, 2000);
	});


	console.log(p.value)
</script>

</html>