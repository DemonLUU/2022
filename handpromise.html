<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<title></title>
</head>

<body>
</body>
<script>
	class myPromise {
		constructor(fn) {
			this.state = 'pending'
			this.result = null
			this.reason = null
			this.onFulfilledList = []
			this.onRejectList = []

			try {
				fn(this.resolve.bind(this), this.reject.bind(this))
			} catch (e) {
				this.reject(e)
			}


		}

		resolve (result) {
			if (this.state === 'pending') {
				this.state = 'fulfilled'
				this.result = result
				this.onFulfilledList.forEach(cb => {
					cb(this.result)
				})
			}
		}
		reject (reason) {
			if (this.state === 'pending') {
				this.state = 'reject'
				this.reason = reason
				this.onRejectList.forEach(cb => {
					cb(this.reason)
				})
			}
		}

		then (onFulfilled, onReject) {
			let promise2 = new myPromise((resolve, reject) => {
				if (this.state === 'fulfilled') {
					setTimeout(() => {
						try {
							if (typeof onFulfilled !== 'function') {
								resolve(this.result)
							} else {
								let x = onFulfilled(this.result)
								resolvePromise(promise2, x, resolve, reject)
							}

						} catch (e) {
							reject(e)
						}
					})

				} else if (this.state === 'reject') {
					setTimeout(() => {
						try {
							if (typeof onReject !== 'function') {
								reject(this.reason)
							} else {
								let x = onReject(this.reason)
								resolvePromise(promise2, x, resolve, reject)
							}

						} catch (e) {
							reject(e)
						}
					})

				} else if (this.state === 'pending') {
					//数组存储状态
					setTimeout(() => {
						try {
							this.onFulfilledList.push(() => {
								if (typeof onFulfilled !== 'function') {
									resolve(this.result)
								} else {
									let x = onFulfilled(this.result)
									resolvePromise(promise2, x, resolve, reject)
								}

							})
						} catch (e) {
							reject(e)
						}
					})
					setTimeout(() => {
						try {
							this.onRejectList.push(() => {
								if (typeof onReject !== 'function') {
									reject(this.onRejectList)
								} else {
									let x = onReject(this.onRejectList)
									resolvePromise(promise2, x, resolve, reject)
								}

							})
						} catch (e) {
							reject(e)
						}
					})


				}

			})

			return promise2
		}


	}

	function resolvePromise (promise2, x, resolv, reject) {
		if (x === promise2) {
			throw new TypeError('====')
		}
		if (x instanceof myPromise) {
			x.then(y => {
				resolvePromise(promise2, x, resolv, reject)
			}, reject)
		} else if ((x !== null && (typeof x === 'object' || (typeof x === 'function')))) {
			try {
				let then = x.then
			} catch (e) {
				reject(e)
			}
			if (typeof then === 'function') {
				try {
					then.call(
						x,
						y => {
							resolvePromise(promise2, y, resolv, reject)
						},
						r => {
							resolv(r)
						})
				} catch (e) {
					reject(e)
				}
			} else {
				resolv(x)
			}
		} else {
			return resolv(x)
		}
	}

	let p = new myPromise(function (resolve, reject) {
		//做一些异步操作
		resolve('要返回的数据可以任何数据例如接口返回数据');
	});


	console.log(p.value)
</script>

</html>